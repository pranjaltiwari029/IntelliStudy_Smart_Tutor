[{"front": "Two Sum", "back": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target."}, {"front": "Reverse Linked List", "back": "Given the head of a singly linked list, reverse the list and return the reversed list."}, {"front": "Binary Tree Inorder Traversal", "back": "Given the root of a binary tree, return the inorder traversal of its nodes' values."}, {"front": "Valid Parentheses", "back": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid."}, {"front": "Merge Two Sorted Lists", "back": "Merge two sorted linked lists and return it as a sorted list."}, {"front": "Maximum Subarray", "back": "Find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."}, {"front": "Product of Array Except Self", "back": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]."}, {"front": "3Sum", "back": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0."}, {"front": "Container With Most Water", "back": "Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water."}, {"front": "Search in Rotated Sorted Array", "back": "Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums."}, {"front": "Longest Substring Without Repeating Characters", "back": "Given a string s, find the length of the longest substring without repeating characters."}, {"front": "Longest Palindromic Substring", "back": "Given a string s, return the longest palindromic substring in s."}, {"front": "Zigzag Conversion", "back": "The string \"PAYPALISHIRING\", is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)"}, {"front": "String to Integer (atoi)", "back": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function)."}, {"front": "Roman to Integer", "back": "Given a roman numeral, convert it to an integer."}, {"front": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n \n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n ", "back": "If you check all possible pairs, we need two loops which is O(n \n2\n ).\n\nInput: nums = [2,7,11,15], target = 9\nAll possible pairs are\n\n[2,2][2,7][2,11][2,15] = 4\n[7,2][7,7][7,11][7,15] = 4\n[11,2][11,7][11,11][11,15] = 4\n[15,2][15,7][15,11][15,15] = 4\n\ntotal 16 pairs\nAnd then, we need to find the right pair among them. They are including invalid pairs but at least we need to iterate input array 16 times which is 4^2. 4 is the length of input array.\n\nLooping 16 times is not a big deal. But what if we have 100 or 1000 numbers as an input array. Do we loop 10000 or 1000000 times?\n\nThat's why if we can improve the time complexity to O(n), we will loop 100 or 1000 at most. It's much much much better right?\n\nHow can we improve the time complexity?\nMy answer is to use a memory to keep results of something my solution code has done.\n\n\u2b50\ufe0f Points\n\nUse a memory to keep data for something to improve time complexity.\n\nIn this case, HashMap is good data structure.\n\nWhat is data we should keep with HashMap?\nLet's take a look at input array and target number.\n\nInput: nums = [2,7,11,15], target = 9\nIn this case, if we subtract current number in input array from target number, we can get a number we need to create the target number.\n\nFor example,\n\n9 - 2 = 7\n7 is a number we need when current number is 2. So if we have 7 and index number of 7, we can create 9 with the current(= 2) number and 7.\n\nFrom this example, what we should keep in HashMap is\n\n\u2b50\ufe0f Points\n\nKeep numbers(elements) as keys and index numbers as values in the input array.\n\nLet's iterate through one by one.\n\nInput: nums = [2,7,11,15], target = 9\nLet's call the HashMap pair_idx.\n\n[2,7,11,15], target = 9\n\u3000\u3000\u2191\n\npair_idx = {} \nWe found 2. we need 7 to create 9, so check if we have 7 in pair_idx. But now pair_idx is empty, so just add current number and its index to pair_idx.\n\npair_idx = {2: 0} \n\n2 is current number\n0 is index of 2\nThen move next."}]